import type { IGolangPluginConfig } from './config'
import * as templates from './templates'
import { Liquid, Template } from 'liquidjs'
import {
  DocumentNode,
  EnumTypeDefinitionNode,
  GraphQLSchema,
  InputObjectTypeDefinitionNode,
  ObjectTypeDefinitionNode,
  parse,
  print,
  printSchema,
  TypeInfo,
  TypeNode,
  VariableDefinitionNode,
  visit,
  visitWithTypeInfo,
} from 'graphql'

/**
 * GolangGenerator is a class that you instantiate with a GraphQL schema
 * and an optional configuration. You can then call its method `generate`
 * to generate Golang code.
 */
export class GolangGenerator {
  /**
   * The configuration used when generating Golang code.
   */
  public readonly config: IGolangPluginConfig

  /**
   * The GraphQL schema used to generate Golang code.
   */
  public readonly schema: GraphQLSchema

  private _templateEngine: Liquid
  private _templateOperation: Template[]

  /**
   * Map GraphQL type to their Golang format.
   */
  public readonly types: { [key: string]: string } = {
    Int: 'Int',
    Float: 'Float',
    Boolean: 'Boolean',
    String: 'String',
    ID: 'ID',
  }
  /**
   * Map GraphQL scalar types to Golang types.
   */
  public readonly scalars: { [key: string]: string } = {
    Int: 'int32',
    Float: 'float64',
    Boolean: 'bool',
    String: 'string',
    ID: 'string',
  }
  private _enums: EnumTypeDefinitionNode[] = []
  private _inputs: InputObjectTypeDefinitionNode[] = []
  private _objects: ObjectTypeDefinitionNode[] = []

  public constructor(schema: GraphQLSchema, config?: IGolangPluginConfig) {
    this.config = config ?? {}
    this.config.generateHTTPClient ??= true
    this.config.skipUnsupportedTypes ??= false
    this.schema = schema
    this._templateEngine = new Liquid({
      strictFilters: true,
      strictVariables: true,
    })
    this._templateOperation = this._templateEngine.parse(
      templates.GOLANG_OPERATION
    )
    visit(parse(printSchema(this.schema)), {
      ScalarTypeDefinition: node => {
        this.types[node.name.value] = this._formatName(node.name.value)
        this.scalars[node.name.value] = 'string'
        return false
      },
      EnumTypeDefinition: node => {
        this.types[node.name.value] = this._formatName(node.name.value)
        this._enums.push(node)
        return false
      },
      InputObjectTypeDefinition: node => {
        this.types[node.name.value] = this._formatName(node.name.value)
        this._inputs.push(node)
        return false
      },
      ObjectTypeDefinition: node => {
        this.types[node.name.value] = this._formatName(node.name.value)
        this._objects.push(node)
        return false
      },
    })
  }

  public generate(documents?: DocumentNode[]): string {
    const l: string[] = [...this._generatePackage(), ...this._generateImports()]
    if (this.config.generateHTTPClient) {
      l.push(templates.GOLANG_HTTP)
      documents?.forEach(document =>
        l.push(...this._generateOperations(document))
      )
    }
    l.push(...this._generateSchema())
    return l.join('\n')
  }

  /**
   * Format a name for Golang.
   * @param name - Name to format.
   */
  private _formatName(name: string): string {
    if (name.match(/^id$/i) || name.match(/^uuid$/i)) {
      return name.toUpperCase()
    }
    return name
      .replace(/(^_|_$)/, '')
      .split('_')
      .map(word => word[0]?.toUpperCase() + word.substr(1))
      .join('')
  }

  /**
   * Generate Golang package header.
   */
  private _generatePackage(): string[] {
    return [
      `package ${this.config.packageName ?? 'graphql'}`,
      '',
      '// Code generated by graphql-codegen-golang ; DO NOT EDIT.',
      '',
    ]
  }

  /**
   * Generate Golang imports for operations.
   */
  private _generateImports(): string[] {
    if (this.config.generateHTTPClient) {
      return [
        'import (',
        '  "bytes"',
        '  "encoding/json"',
        '  "fmt"',
        '  "io/ioutil"',
        '  "net/http"',
        '  "strings"',
        ')',
        '',
      ]
    }
    return []
  }

  /**
   * Generate a named comment section.
   * @param name - Name of the section.
   */
  private _generateSection(name: string): string[] {
    return ['', '//', `// ${name}`, '//', '']
  }

  /**
   * Generate the Golang types from schema.
   */
  private _generateSchema(): string[] {
    return [
      ...this._generateScalars(),
      ...this._generateEnums(),
      ...this._generateInputs(),
      ...this._generateObjects(),
    ]
  }

  private _generateScalars(): string[] {
    const l: string[] = [...this._generateSection('Scalars')]
    Object.entries(this.scalars).map(([gqlType, goType]) => {
      l.push(`type ${this.types[gqlType]} ${goType}`)
    })
    return l
  }

  private _generateEnums(): string[] {
    const l: string[] = [...this._generateSection('Enums')]
    this._enums.forEach(node => {
      const goType: string = this.types[node.name.value] as string
      l.push('', `type ${this.types[node.name.value]} string`, 'const (')
      node.values?.forEach(value => {
        const name: string = value.name.value
        l.push(`  ${goType}${this._formatName(name)} ${goType} = "${name}"`)
      })
      l.push(')')
    })
    return l
  }

  private _generateInputs(): string[] {
    const l: string[] = [...this._generateSection('Inputs')]
    this._inputs.forEach(node => {
      const goType: string = this.types[node.name.value] as string
      l.push('', `type ${goType} struct {`)
      node.fields?.forEach(field => {
        l.push(this._generateField(field.name.value, field.type))
      })
      l.push('}')
    })
    return l
  }

  private _generateObjects(): string[] {
    const l: string[] = [...this._generateSection('Objects')]
    this._objects.forEach(node => {
      const goType: string = this.types[node.name.value] as string
      l.push('', `type ${goType} struct {`)
      node.fields?.forEach(field => {
        try {
          l.push(this._generateField(field.name.value, field.type))
        } catch (e) {
          if (!this.config.skipUnsupportedTypes) {
            throw e
          }
        }
      })
      l.push('}')
    })
    return l
  }

  /**
   * Generate a Golang struct's field.
   * @param name - Name of the GraphQL field.
   * @param type - Type of the GraphQL field.
   */
  private _generateField(name: string, type: TypeNode): string {
    return `  ${this._formatName(name)} ${this._generateFieldType(type, name)}`
  }

  /**
   *
   * @param type - TypeNode contains a GraphQL type.
   * @param fieldName - GraphQL field's name for the Golang's json annotation.
   * @param prefix - String accumulator to add to result when recursion is done.
   * @param nonNull - Boolean accumulator to determine if type must be a pointer.
   */
  private _generateFieldType(
    type: TypeNode,
    fieldName: string,
    prefix: string = '',
    nonNull: boolean = false
  ): string {
    if (type.kind === 'NamedType' && this.types[type.name.value]) {
      return [
        `${nonNull ? '' : '*'}${prefix}`,
        `${this.types[type.name.value]} `,
        `\`json:"${fieldName}${nonNull ? '' : ',omitempty'}"\``,
      ].join('')
    }
    if (type.kind === 'NonNullType') {
      return this._generateFieldType(
        type.type,
        fieldName,
        prefix,
        prefix !== '' ? false : true
      )
    }
    if (type.kind === 'ListType') {
      return this._generateFieldType(
        type.type,
        fieldName,
        prefix + '[]',
        nonNull
      )
    }
    throw new Error(`field type "${type.name.value}" not supported!`)
  }

  /**
   * Generate operations code from a GraphQL document.
   * @param document - Document to get the operations from.
   */
  private _generateOperations(document: DocumentNode): string[] {
    const l: string[] = []
    const typeInfo: TypeInfo = new TypeInfo(this.schema)
    visit(
      document,
      visitWithTypeInfo(typeInfo, {
        OperationDefinition: {
          enter: operation => {
            // Anonymous operation are not supported: skip them.
            if (!operation.name) return false
            // Subscription operations are not supported yes.
            if (operation.operation === 'subscription') return false
            const name: string = this._formatName(operation.name.value)
            l.push(
              ...this._generateSection(
                `${print(operation).split('{', 1)[0]?.trim()}`
              )
            )
            // Generate operation variables type if any
            l.push(
              ...this._generateOperationVariables(
                name,
                operation.variableDefinitions
              )
            )
            // Finally, operation's response type are generated when visiting
            // inner AST nodes
            l.push(`type ${name}Response struct {`)
            return
          },
          leave: operation => {
            if (!operation.name) return
            // Inner nodes have been visited. Time to close response type.
            l.push('}', '')
            const name: string = this._formatName(operation.name.value)
            const hasVariables: boolean =
              this._generateOperationVariables(
                name,
                operation.variableDefinitions
              ).length > 0
            // Generate everything except variables and response type
            l.push(
              ...this._generateOperationCode(
                name,
                print(operation),
                hasVariables
              )
            )
          },
        },
        Field: {
          enter: field => {
            const name: string = this._formatName(field.name.value)
            const w: string[] = [`  ${name} `]
            if (field.selectionSet) {
              const outputType: string | undefined = typeInfo
                .getType()
                ?.toString()
              if (outputType?.startsWith('[')) {
                if (!outputType.endsWith('!')) {
                  w.push('*')
                }
                w.push('[]')
              }
              w.push('struct {')
            } else {
              w.push(`string \`json:"${field.name.value}"\``)
            }
            l.push(w.join(''))
          },
          leave: field => {
            if (field.selectionSet) {
              l.push(`} \`json:"${field.name.value}"\``)
            }
          },
        },
      })
    )
    return l
  }

  /**
   * Generate Golang `type ${name}Variables struct {...}`.
   * @param name - Name of the operation. Must be formatted for Golang.
   * @param variableDefinitions - GraphQL variables to generate Golang fields from.
   */
  private _generateOperationVariables(
    name: string,
    variableDefinitions: readonly VariableDefinitionNode[] | undefined
  ): string[] {
    if (!variableDefinitions || variableDefinitions.length === 0) {
      return []
    }
    const l: string[] = [`type ${name}Variables struct {`]
    variableDefinitions.forEach(variable => {
      l.push(this._generateField(variable.variable.name.value, variable.type))
    })
    l.push('}', '')
    return l
  }

  /**
   * Generates all Golang code for an operation except `type ${name}Variables`
   * and `type ${name}Response`.
   * @param name - Name of the operation. Must be formatted for Golang.
   * @param operation - String version of the operation.
   * @param hasVariables - Whether the operation uses a `${name}Variables` or not.
   */
  private _generateOperationCode(
    name: string,
    operation: string,
    hasVariables: boolean
  ): string[] {
    const l: string[] = []
    l.push(
      this._templateEngine.renderSync(this._templateOperation, {
        name,
        operation,
        hasVariables,
      })
    )
    return l
  }
}
